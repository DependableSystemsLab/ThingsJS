{"name":"testSTAT","components":[{"name":"SenMLParse.js","source":"/* \n * SenMLParse file adapted from RIoTBench (SenMLParse.java)\n */\n\n//var things = require('things-js');\nvar things = require('things-js')\n\n/* configurable variables */\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLSpout';\nvar publish_topic = 'thingsjs/IoTBench/SenMLParse';\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\nfunction processMessage(data) {\n\tvar line = data.toString();\n\t\n\t// Remove everything before first { -- dunno why the data is made like that\n\tvar trimmedLine = line.substr(line.indexOf('{'));\n\t\n\t// JSON-parse object\n\tvar obj = JSON.parse(trimmedLine);\n\t//console.log(obj);\n\t\n\t// What follows is derived from the logic in SenMLParse\n\t// Ensuring compatibility as much as possible so that we can properly\n\t// implement / port the next \"steps\".\n\tvar baseTime = 'bt' in obj ? obj['bt'] : 0;\n\tvar baseUnit = 'bu' in obj ? obj['bu'] : \"\";\n\tvar baseName = 'bn' in obj ? obj['bn'] : \"\";\n\tvar jsonArr = obj['e'];\n\t\n\tvar v,n,u,t;\n\t\n\tvar mapkeyvalues = {};\n\t\n\t//console.log(jsonArr);\n\t\n\tfor (var j=0; j<jsonArr.length; j++) {\n\t\tvar jsonObject = jsonArr[j];\n\t\t//console.log(jsonObject);\n\n\t\tv = 'v' in jsonObject ? jsonObject['v'] : jsonObject['sv'];\n\t\tt = 'v' in jsonObject ? jsonObject['t'] : 0;\n\t\tt += baseTime;\n\n\t\t/* if name does not exist, consider base name */\n\t\tn = 'n' in jsonObject ? jsonObject['n'] : baseName;\n\t\tu = 'u' in jsonObject ? jsonObject['u'] : baseUnit;\n\n\t\tmapkeyvalues[n] = v;\n\t}\n\t\n\t\n\t// Publish the output\n\tconsole.log(mapkeyvalues);\n    pubsub.publish(publish_topic, mapkeyvalues);\n}\n\n/* Connect pubsub */\npubsub.on('ready', function(){\n    \n\t// Subscribe to spout publications\n\tpubsub.subscribe(pubsub_topic, processMessage);\n});\n","count":1,"required_memory":1,"component_id":"5ba0511c8797ac7bc20a731a"},{"name":"SenMLSpout.js","source":"/* \n * Publishes SenML data over pub sub\n */\n\n//var things = require('things-js');\nvar things = require('things-js');\nvar readline = require('readline');\n\n/* configurable variables */\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLSpout';\nvar publish_interval = 1000;\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\n/* SenML Lines */\nvar lines = [];\nvar currentLine = 0;\n\nfunction startSpout() {\n\tvar lineReader = readline.createInterface({\n\t\tinput: require('fs').createReadStream('TAXI_sample_data_senml.csv')\n\t});\n\n\tlineReader.on('line', function (line) {\n\t\t//console.log('Line from file:', line);\n\t\tlines.push(line);\n\t});\n\n\tlineReader.on('close', function() {\n\t\t// File ended\n\t\tconsole.log('Done reading file... Starting to publish');\n\t\tsetInterval(publishLine, publish_interval);\n\t});\t\n}\n\n/* Publish a SenML line */\nfunction publishLine() {\n\t// For the moment, publish as a raw string rather than json-serializing\n\t// since de-jsoning will be performed by the next 'bolt'\n\tif (currentLine >= lines.length) {\n\t\t/*\n\t\tconsole.log(\"Done sending data.\");\n\t\treturn;\n\t\t*/\n\t   currentLine = 0;\n\t}\n\tconsole.log(\"Publishing line \" + currentLine);\n\tpubsub.publish(pubsub_topic, lines[currentLine]);\n\tcurrentLine++;\n}\n\npubsub.on('ready', function(){\n    console.log(\"Beginning spout\");\n    startSpout();\n});\n\n","count":1,"required_memory":1,"component_id":"5ba0513d8797ac7bc20a731b"},{"name":"Plot.js","source":"var things = require('things-js');\nvar fs = require('fs');\nvar express = require('express');\nvar bodyParser = require('body-parser');\n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/STATS/Accumulator';\n\n/* plot fields */\nvar plotData = [];\nvar plotFile;\nvar PLOT_WINDOW;\nvar count = 0;\n\nvar app = express();\nvar pubsub = new things.Pubsub(pubsub_url);\n\nfunction setup(){\n\tvar args = process.argv.slice(2);\n\tvar properties;\n\n\tif(!args.length){\n\t\targs = ['./TAXI_properties.json'];\n\t}\n\ttry{\n\t\tproperties = JSON.parse(fs.readFileSync(args[0], 'utf-8'));\n\t}\n\tcatch(e){\n\t\tconsole.log('Problem reading properties file: '+e);\n\t\tprocess.exit();\n\t}\n\tPLOT_WINDOW = properties['VISUALZE.PLOT.WINDOW_SIZE'] || 10;\n\tinitServer();\n}\n\nfunction initServer(){\n\tapp.use(express.json());\n\tapp.use(bodyParser.urlencoded({ extended: true }));\n\n\tapp.use(function(req, res, next){\n\t  res.header(\"Access-Control-Allow-Origin\", \"*\");\n\t  res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n\t  next();\n\t});\n\n\tapp.set('port', (process.env.PORT || 5000));\n\tapp.listen(app.get('port'), function(){\n\t\tconsole.log('Server started');\n\t\tapp.get('/points', function(req, res){\n\t\t\tres.json(plotData);\n\t\t\tres.end();\n\t\t});\n\t});\n}\n\nfunction task(data){\n\tcount++;\n\tfor(field in data){\n\t\tvar values = data[field];\n\n\t\tvalues.forEach(function(val){\n\t\t\tvar pt = {};\n\t\t\tpt['ts'] = val['ts'];\n\t\t\tpt[field] = val['value'];\n\t\t\tif(count >= PLOT_WINDOW){\n\t\t\t\tplotData.shift();\n\t\t\t}\n\t\t\tplotData.push(pt);\n\t\t});\n\t}\n}\n\npubsub.on('ready', function(){\n\tsetup();\n\tconsole.log('Beginning plot');\n\tpubsub.subscribe(pubsub_topic, task);\n});\n","count":1,"required_memory":1,"component_id":"5baa7e83a0f9fa64ff960da8"},{"name":"Accumulator.js","source":"var things = require('things-js');\nvar fs = require('fs');\n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topics = ['SLR', 'DistinctApproxCount', 'BlockWindowAverage']\nvar pubsub_heading = 'thingsjs/IoTBench/STATS/';\nvar publish_topic = 'thingsjs/IoTBench/STATS/Accumulator';\n\n/* accumulator fields */\nvar WINDOW_SIZE;\nvar accumulation = {};\nvar counter = 0;\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\nfunction setup(){\n\tvar args = process.argv.slice(2);\n\tvar properties;\n\n\t// default to TAXI property set if no specific property file is given\n\tif(!args.length){\n\t\targs = ['./TAXI_properties.json'];\n\t}\n\ttry{\n\t\tproperties = JSON.parse(fs.readFileSync(args[0], 'utf-8'));\n\t}\n\tcatch(e){\n\t\tconsole.log('Problem reading properties file: ' + e);\n\t\tprocess.exit();\n\t}\n\tWINDOW_SIZE = properties['AGGREGATE.ACCUMULATOR.TUPLE_WINDOW_SIZE'];\n}\n\nfunction accumulate(data){\n\tcounter++;\n\tvar time = Date.now();\n\n\tfor(field in data){\n\t\tvar obj = { value: data[field], ts: time };\n\t\tif(field in accumulation){\n\t\t\taccumulation[field].push(obj);\n\t\t}\n\t\telse{\n\t\t\taccumulation[field] = [obj];\n\t\t}\n\t}\n\tif(counter === WINDOW_SIZE){\n\t\tconsole.log(JSON.stringify(accumulation));\n\t\tpubsub.publish(publish_topic, accumulation);\n\t\taccumulation = {};\n\t\tcounter = 0;\n\t}\n}\n\npubsub.on('ready', function(){\n\tsetup();\n\tconsole.log('Beginning accumulation');\n\tpubsub_topics.forEach(function(topic){\n\t\tpubsub.subscribe(pubsub_heading + topic, accumulate);\n\t});\n});\n","count":1,"required_memory":1,"component_id":"5baa7e6ea0f9fa64ff960da7"},{"name":"SimpleLinearRegression.js","source":"var things = require('things-js');\nvar fs = require('fs');\n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/STATS/KalmanFilter';\nvar publish_topic = 'thingsjs/IoTBench/STATS/SLR';\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\n/* linear regression fields */\nvar MODEL_PATH, USE_MSG_FIELDLIST;\nvar b_0, b_1;\n\nfunction setup(){\n\tvar args = process.argv.slice(2);\n\tvar properties;\n\n\t// default to TAXI property set if no specific property file is given\n\tif(!args.length){\n\t\targs = ['./TAXI_properties.json'];\n\t}\n\ttry{\n\t\tproperties = JSON.parse(fs.readFileSync(args[0], 'utf-8'));\n\t}\n\tcatch(e){\n\t\tconsole.log('Problem reading properties file: ' + e);\n\t\tprocess.exit();\n\t}\n\tUSE_MSG_FIELDLIST = properties['PREDICT.SIMPLE_LINEAR_REGRESSION.USE_MSG_FIELD_LIST'];\n\tMODEL_PATH = properties['PREDICT.SIMPLE_LINEAR_REGRESSION.MODEL_PATH'];\n\ttry{\n\t\tconsole.log(MODEL_PATH);\n\t\tvar coefficients = JSON.parse(fs.readFileSync(MODEL_PATH, 'utf-8'));\n\t\tb_0 = coefficients[0];\n\t\tb_1 = coefficients[1];\n\t}\n\tcatch(e){\n\t\tconsole.log('Problem fetching linear regression model from file path: ' + e);\n\t\tprocess.exit();\n\t}\n}\n\nfunction linearRegression(data){\n\tvar xKey = USE_MSG_FIELDLIST[0];\n\tvar yKey = USE_MSG_FIELDLIST[1];\n\tvar prediction = b_0 + b_1 * data[xKey];\n\tconsole.log('Prediction: ' +prediction +'. Actual: '+data[yKey]);\n\n\tvar predictionJSON = {};\n\tpredictionJSON[yKey + '_prediction'] = prediction;\n\tpredictionJSON[yKey + '_actual'] = data[yKey];\n\tpubsub.publish(publish_topic, predictionJSON);\n}\n\npubsub.on('ready', function(){\n\tsetup();\n\tconsole.log('Beginning linear regression');\n\tpubsub.subscribe(pubsub_topic, linearRegression);\n});\n","count":1,"required_memory":1,"component_id":"5baa7e57a0f9fa64ff960da6"},{"name":"KalmanFilter.js","source":"var things = require('things-js');\nvar fs = require('fs');\n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLParse';\nvar publish_topic = 'thingsjs/IoTBench/STATS/KalmanFilter';\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\n/* kalman filter properties */\nvar PROCESS_NOISE, SENSOR_NOISE, USE_MSG_FIELD, USE_MSG_FIELDLIST;\nvar previousEstimation;\nvar prevErrorCovariance;\n\nfunction setup(){\n\tvar args = process.argv.slice(2);\n\tvar properties;\n\n\t// default to TAXI property set if no specific property file is given\n\tif(!args.length){\n\t\targs = ['./TAXI_properties.json'];\n\t}\n\ttry{\n\t\tproperties = JSON.parse(fs.readFileSync(args[0], 'utf-8'));\n\t}\n\tcatch(e){\n\t\tconsole.log('Problem reading properties file: ' + e);\n\t\tprocess.exit();\n\t}\n\tUSE_MSG_FIELD = properties['STATISTICS.KALMAN_FILTER.USE_MSG_FIELD'] || 0;\n\tUSE_MSG_FIELDLIST = properties['STATISTICS.KALMAN_FILTER.USE_MSG_FIELD_LIST'];\n\tSENSOR_NOISE = properties['STATISTICS.KALMAN_FILTER.SENSOR_NOISE'] || 0.1;\n\tPROCESS_NOISE = properties['STATISTICS.KALMAN_FILTER.PROCESS_NOISE'] || 0.1;\n\tprevErrorCovariance = properties['STATISTICS.KALMAN_FILTER.ESTIMATED_ERROR'] || 1;\n\tpreviousEstimation = 0;\n}\n\nfunction kalmanfilter(data){\n\tvar z_measureValue;\n\tvar field;\n\n\tif(USE_MSG_FIELD > 0){\n\t\tfield = USE_MSG_FIELDLIST[USE_MSG_FIELD-1];\n\t\tz_measureValue = data[field];\n\t}\n\telse if(USE_MSG_FIELD == 0){\n\t\tz_measureValue = data[USE_MSG_FIELDLIST];\n\t}\n\telse{\n\t\t// generate a value of 10 +/- 1.0\n\t\tz_measureValue = 10 + ((Math.random() >= 0.5) ? -1 : 1) * (Math.random().toFixed(1));\n\t}\n\n\tvar currErrorCovariance = prevErrorCovariance + PROCESS_NOISE;\n\tvar kalmanGain = currErrorCovariance / (currErrorCovariance + SENSOR_NOISE);\n\tvar currentEstimation = previousEstimation + kalmanGain * (z_measureValue - previousEstimation);\n\n\tcurrErrorCovariance = ( 1 - kalmanGain ) * currErrorCovariance;\n\tpreviousEstimation = currentEstimation;\n\tprevErrorCovariance = currErrorCovariance;\n\n\tif(USE_MSG_FIELD >= 0){\n\t\tconsole.log(\"Fixed value for field \" + field + \" from \" + z_measureValue + \" to \" + currentEstimation);\n\t\tdata[field] = currentEstimation;\n\t}\n\tpubsub.publish(publish_topic, data);\n}\n\npubsub.on('ready', function(){\n\tsetup();\n\tconsole.log('Beginning Kalman Filter');\n\tpubsub.subscribe(pubsub_topic, kalmanfilter);\n});\n","count":1,"required_memory":1,"component_id":"5baa7e36a0f9fa64ff960da5"},{"name":"BlockWindowAverage.js","source":"var things = require('things-js');\nvar fs = require('fs');\n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLParse';\nvar publish_topic = 'thingsjs/IoTBench/STATS/BlockWindowAverage';\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\n/* avg fields */\nvar BLOCK_AVG, USE_MSG_FIELD, USE_MSG_FIELDLIST;\nvar aggCount, aggSum, aggRes;\n\nfunction setup(){\n\tvar args = process.argv.slice(2);\n\tvar properties;\n\n\t// default to TAXI property set if no specific property file is given\n\tif(!args.length){\n\t\targs = ['./TAXI_properties.json'];\n\t}\n\ttry{\n\t\tproperties = JSON.parse(fs.readFileSync(args[0], 'utf-8'));\n\t}\n\tcatch(e){\n\t\tconsole.log('Problem reading properties file: ' + e);\n\t\tprocess.exit();\n\t}\n\tBLOCK_AVG = properties['AGGREGATE.BLOCK_COUNT.WINDOW_SIZE'];\n\tUSE_MSG_FIELD = properties['AGGREGATE.BLOCK_COUNT.USE_MSG_FIELD'] || 0;\n\tUSE_MSG_FIELDLIST = properties['AGGREGATE.BLOCK_COUNT.USE_MSG_FIELD_LIST'];\n\n\taggCount = 0;\n\taggSum = 0;\n}\n\nfunction average(data){\n\tvar field;\n\tif(USE_MSG_FIELD > 0){\n\t\tfield = USE_MSG_FIELDLIST[USE_MSG_FIELD-1];\n\t}\n\telse{\n\t\tvar keys = Object.keys(data);\n\t\tvar ranIndex = Math.ceil( Math.random() * keys.length );\n\t\tfield = keys[ranIndex];\n\t}\n\ttry{\n\t\taggSum += Number(data[field]);\n\t}\n\tcatch(e){\n\t\tconsole.log('Field value must be a number');\n\t\treturn;\n\t}\n\taggCount++;\n\n\tif(aggCount > BLOCK_AVG){\n\t\taggRes = aggSum / BLOCK_AVG;\n\t\taggCount = 0;\n\t\taggSum = 0;\n\n\t\tconsole.log('Average ' + field + ' over ' + BLOCK_AVG + ' values: ' + aggRes);\n\t\tvar avgJSON = {};\n\t\tavgJSON[field + '_average'] = aggRes;\n\n\t\tpubsub.publish(publish_topic, avgJSON);\n\t}\n}\n\npubsub.on('ready', function(){\n\tsetup();\n\tconsole.log('Beginning Average');\n\tpubsub.subscribe(pubsub_topic, average);\n});\n","count":1,"required_memory":1,"component_id":"5baa7e1fa0f9fa64ff960da4"},{"name":"DistinctApproxCount.js","source":"var things = require('things-js');\nvar fs = require('fs');\nvar crypto = require('crypto');\n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLParse';\nvar publish_topic = 'thingsjs/IoTBench/STATS/DistinctApproxCount';\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\n/* DAC properties */\nvar BUCKET_SIZE, USE_MSG_FIELD, USE_MSG_FIELDLIST;\nvar maxZeroes = [];\nvar numBuckets;\n\nfunction setup(){\n\tvar args = process.argv.slice(2);\n\tvar properties;\n\n\t// default to TAXI property set if no specific property file is given\n\tif(!args.length){\n\t\targs = ['./TAXI_properties.json'];\n\t}\n\ttry{\n\t\tproperties = JSON.parse(fs.readFileSync(args[0], 'utf-8'));\n\t}\n\tcatch(e){\n\t\tconsole.log('Error reading properties file: ' + e);\n\t\tprocess.exit();\n\t}\n\n\tBUCKET_SIZE = properties['AGGREGATE.DISTINCT_APPROX_COUNT.BUCKETS'] || 10;\n\tif(BUCKET_SIZE > 31){\n\t\tconsole.log('Bucket size is too large. Must be less than or equal to 31');\n\t\tprocess.exit();\n\t}\n\tnumBuckets = 1 << BUCKET_SIZE;\n\n\tUSE_MSG_FIELD = properties['AGGREGATE.DISTINCT_APPROX_COUNT.USE_MSG_FIELD'] || 0;\n\tUSE_MSG_FIELDLIST = properties['AGGREGATE.DISTINCT_APPROX_COUNT.USE_MSG_FIELD_LIST'];\n\n\tfor(var i = 0; i < numBuckets; i++){\n\t\tmaxZeroes[i] = 0;\n\t}\n}\n\nfunction doUniqueCount(data){\n\tvar field;\n\n\tif(USE_MSG_FIELD > 0){\n\t\tfield = USE_MSG_FIEDLIST[USE_MSG_FIELD-1];\n\t}\n\telse if(USE_MSG_FIELD == 0){\n\t\tfield = USE_MSG_FIELDLIST;\n\t\tconsole.log(field);\n\t}\n\telse{\n\t\tvar keys = Object.keys(data);\n\t\tvar ranIndex = Math.ceil( Math.random() * keys.length );\n\t\tfield = keys[ranIndex];\n\t}\n\tvar count = countUniqueItems(data[field]);\n\tvar uniqueCountJSON = {};\n\tuniqueCountJSON[field + '_distinctCount'] = count;\n\n\tconsole.log('Approx ' + count + ' unique items in ' + field);\n\tpubsub.publish(publish_topic, uniqueCountJSON);\n}\n\nfunction countUniqueItems(item){\n\n\tfunction sha1(str){\n\t\tvar sha = crypto.createHash('sha1');\n\t\tvar hex = sha.update(str).digest('hex');\n\t\treturn hex;\n\t}\n\tvar magicNum = 0.79402;\n\tvar hashValue = parseInt(sha1(item), 16);\n\tvar bucketId = hashValue & (numBuckets - 1);\n\n\tvar currMax = maxZeroes[bucketId];\n\tmaxZeroes[bucketId] = Math.max(currMax, countTrailZeroes(hashValue >> BUCKET_SIZE));\n\n\tvar sumMaxZeroes = 0;\n\tfor(var i = 0; i < numBuckets; i++){\n\t\tsumMaxZeroes += maxZeroes[i];\n\t}\n\n\tvar E = (magicNum * numBuckets * Math.pow(2, sumMaxZeroes / numBuckets));\n\treturn E;\n}\n\nfunction countTrailZeroes(val){\n\tif(val === 0){\n\t\treturn 31;\n\t}\n\telse{\n\t\tvar p = 0;\n\t\twhile( ((val >> p) & 1) === 0){\n\t\t\tp++;\n\t\t}\n\t\treturn p;\n\t}\n}\n\npubsub.on('ready', function(){\n\tsetup();\n\tconsole.log('Beginning Distinct Approx. Count');\n\tpubsub.subscribe(pubsub_topic, doUniqueCount);\n});\n","count":1,"required_memory":1,"component_id":"5baa7d447bc32f56db7a741d"}]}