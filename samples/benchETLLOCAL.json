{"name":"testETL","components":[{"name":"SenMLParse.js","source":"/* \n * SenMLParse file adapted from RIoTBench (SenMLParse.java)\n */\n\n//var things = require('things-js');\nvar things = require('things-js')\n\n/* configurable variables */\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLSpout';\nvar publish_topic = 'thingsjs/IoTBench/SenMLParse';\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\nfunction processMessage(data) {\n\tvar line = data.toString();\n\t\n\t// Remove everything before first { -- dunno why the data is made like that\n\tvar trimmedLine = line.substr(line.indexOf('{'));\n\t\n\t// JSON-parse object\n\tvar obj = JSON.parse(trimmedLine);\n\t//console.log(obj);\n\t\n\t// What follows is derived from the logic in SenMLParse\n\t// Ensuring compatibility as much as possible so that we can properly\n\t// implement / port the next \"steps\".\n\tvar baseTime = 'bt' in obj ? obj['bt'] : 0;\n\tvar baseUnit = 'bu' in obj ? obj['bu'] : \"\";\n\tvar baseName = 'bn' in obj ? obj['bn'] : \"\";\n\tvar jsonArr = obj['e'];\n\t\n\tvar v,n,u,t;\n\t\n\tvar mapkeyvalues = {};\n\t\n\t//console.log(jsonArr);\n\t\n\tfor (var j=0; j<jsonArr.length; j++) {\n\t\tvar jsonObject = jsonArr[j];\n\t\t//console.log(jsonObject);\n\n\t\tv = 'v' in jsonObject ? jsonObject['v'] : jsonObject['sv'];\n\t\tt = 'v' in jsonObject ? jsonObject['t'] : 0;\n\t\tt += baseTime;\n\n\t\t/* if name does not exist, consider base name */\n\t\tn = 'n' in jsonObject ? jsonObject['n'] : baseName;\n\t\tu = 'u' in jsonObject ? jsonObject['u'] : baseUnit;\n\n\t\tmapkeyvalues[n] = v;\n\t}\n\t\n\t\n\t// Publish the output\n\tconsole.log(mapkeyvalues);\n    pubsub.publish(publish_topic, mapkeyvalues);\n}\n\n/* Connect pubsub */\npubsub.on('ready', function(){\n    \n\t// Subscribe to spout publications\n\tpubsub.subscribe(pubsub_topic, processMessage);\n});\n","count":1,"required_memory":1,"component_id":"5ba0511c8797ac7bc20a731a"},{"name":"SenMLSpout.js","source":"/* \n * Publishes SenML data over pub sub\n */\n\n//var things = require('things-js');\nvar things = require('things-js');\nvar readline = require('readline');\n\n/* configurable variables */\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLSpout';\nvar publish_interval = 1000;\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\n/* SenML Lines */\nvar lines = [];\nvar currentLine = 0;\n\nfunction startSpout() {\n\tvar lineReader = readline.createInterface({\n\t\tinput: require('fs').createReadStream('TAXI_sample_data_senml.csv')\n\t});\n\n\tlineReader.on('line', function (line) {\n\t\t//console.log('Line from file:', line);\n\t\tlines.push(line);\n\t});\n\n\tlineReader.on('close', function() {\n\t\t// File ended\n\t\tconsole.log('Done reading file... Starting to publish');\n\t\tsetInterval(publishLine, publish_interval);\n\t});\t\n}\n\n/* Publish a SenML line */\nfunction publishLine() {\n\t// For the moment, publish as a raw string rather than json-serializing\n\t// since de-jsoning will be performed by the next 'bolt'\n\tif (currentLine >= lines.length) {\n\t\t/*\n\t\tconsole.log(\"Done sending data.\");\n\t\treturn;\n\t\t*/\n\t   currentLine = 0;\n\t}\n\tconsole.log(\"Publishing line \" + currentLine);\n\tpubsub.publish(pubsub_topic, lines[currentLine]);\n\tcurrentLine++;\n}\n\npubsub.on('ready', function(){\n    console.log(\"Beginning spout\");\n    startSpout();\n});\n\n","count":1,"required_memory":1,"component_id":"5ba0513d8797ac7bc20a731b"},{"name":"Annotate.js","source":"var things = require('things-js');\nvar fs = require('fs');\nvar readline = require('readline');\n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/ETL/Interpolation';\nvar publish_topic = 'thingsjs/IoTBench/ETL/Annotate';\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\n/* annotation properties */\nvar useMsgField, filePath, schemaTypes;\nvar annotationMap = {};\n\nfunction setup(){\n\tvar args = process.argv.slice(2);\n\tvar properties;\n\n\t// default to TAXI property set if no specific property file is given\n\tif(!args.length){\n\t\targs = ['./TAXI_properties.json'];\n\t}\n\n\ttry{\n\t\tproperties = JSON.parse(fs.readFileSync(args[0], 'utf-8'));\n\t}\n\tcatch(e){\n\t\tconsole.log('Couldn\\'t fetch properties: ' + e);\n\t\tprocess.exit();\n\t}\n\tuseMsgField = properties['ANNOTATE.ANNOTATE_MSG_USE_FIELD'] || 0;\n\tfilePath = properties['ANNOTATE.ANNOTATE_FILE_PATH'];\n\tvar schemaPath = properties['ANNOTATE.ANNOTATE_SCHEMA'];\n\n\tvar x = new Promise(function(resolve){\n\t\treadSchemaTypes(schemaPath).then(function(data){\n\t\t\tschemaTypes = data;\n\t\t\tresolve();\n\t\t});\n\t});\n\tvar y = createAnnotationMap(filePath);\n\n\treturn Promise.all([x,y]);\n}\n\nfunction readSchemaTypes(file){\n\tvar lineReader;\n\treturn new Promise(function(resolve, reject){\n\t\ttry{\n\t\t\tlineReader = readline.createInterface({\n\t\t\t\tinput: fs.createReadStream(file)\n\t\t\t});\n\t\t}\n\t\tcatch(e){\n\t\t\tconsole.log('Problem reading schema: ' + e);\n\t\t\tprocess.exit();\n\t\t}\n\t\tlineReader.on('line', function(line){\n\t\t\tresolve(line);\n\t\t});\n\t});\n}\n\nfunction createAnnotationMap(file){\n\tvar lineReader;\n\n\treturn new Promise(function(resolve, reject){\n\t\ttry{\n\t\t\tlineReader = readline.createInterface({\n\t\t\t\tinput: fs.createReadStream(file)\n\t\t\t});\n\t\t}\n\t\tcatch(e){\n\t\t\tconsole.log('Could not create annotation map: ' + e);\n\t\t\tprocess.exit();\n\t\t}\n\t\tlineReader.on('line', function(line){\n\t\t\tvar token = line.split(':');\n\t\t\tif(token[0] && token[1]){\n\t\t\t\tannotationMap[token[0]] = token[1];\n\t\t\t}\n\t\t});\n\t\tlineReader.on('close', function(){\n\t\t\tconsole.log('Completed annotation map from file');\n\t\t\tresolve();\n\t\t});\n\t});\n}\n\nfunction annotate(data){\n\t// get the annotation key\n\tvar keys = Object.keys(data);\n\tvar field = keys[useMsgField];\n\tvar fieldValue = data[field];\n\tvar annotateValue = annotationMap[fieldValue];\n\n\tif(annotateValue){\n\t\tparsedFields = annotateValue.split(',');\n\t\t// get the missing field names\n\t\tvar schemaArr = schemaTypes.split(',');\n\t\tschemaArr = schemaArr.slice(keys.length + 1, schemaArr.length);\n\n\t\tfor(var i = 0; i < parsedFields.length; i++){\n\t\t\tvar fieldName = schemaArr[i];\n\t\t\tdata[fieldName] = parsedFields[i];\n\t\t}\n\t\tconsole.log('Made annotations to data');\n\t\tconsole.log(schemaArr, parsedFields);\n\t\tconsole.log('\\n');\n\t}\n\tconsole.log('Publishing');\n\tpubsub.publish(publish_topic, data);\n}\n\npubsub.on('ready', function(){\n\tsetup().then(function(){\n\t\tconsole.log('Beginning annotation');\n\t\tpubsub.subscribe(pubsub_topic, annotate);\n\t});\n});\n\n","count":1,"required_memory":1,"component_id":"5ba42d130c95080e6fe3a347"},{"name":"Interpolation.js","source":"var things = require('things-js');\nvar fs = require('fs');\n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjS/IoTBench/ETL/BloomFilterCheck';\nvar publish_topic = 'thingsjs/IoTBench/ETL/Interpolation';\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\n/* interpolation properties */\nvar ID = 'ID';\nvar USE_MSG_FIELD_LIST, WINDOW_SIZE;\nvar valuesMap = {};\n\n// mkdir RIOT/ETL folder if not exist \n// save file inside \nfunction setup(){\n\tvar args = process.argv.slice(2);\n\tvar properties;\n\n\t// default to TAXI property set if no specific property file is given\n\tif(!args.length){\n\t\targs = ['./TAXI_properties.json'];\n\t}\n\ttry{\n\t\tproperties = JSON.parse(fs.readFileSync(args[0], 'utf-8'));\n\t\tUSE_MSG_FIELD_LIST = properties['INTERPOLATION.USE_MSG_FIELD_LIST'];\n\t\tWINDOW_SIZE = properties['INTERPOLATION.WINDOW_SIZE'] || 0;\n\n\t\tif(!USE_MSG_FIELD_LIST){\n\t\t\tconsole.log('No fields to interpolate');\n\t\t\tprocess.exit();\n\t\t}\n\t}\n\tcatch(e){\n\t\tconsole.log('Couldn\\'t fetch properties: ' + e);\n\t\tprocess.exit();\n\t}\n}\n\nfunction interpolate(data){\n\n\tif(WINDOW_SIZE === 0){\n\t\t// do nothing with the data\n\t\tconsole.log('No interpolation needed. Publishing data');\n\t\tpubsub.publish(publish_topic, data);\n\t\treturn;\n\t}\n\n\tUSE_MSG_FIELD_LIST.forEach(function(field){\n\t\tvar key = ID + field;\n\n\t\tif(field in data){\n\n\t\t\tif(key in valuesMap){\n\t\t\t\tif(data[field] === null){\n\t\t\t\t\tvar count = 0;\n\t\t\t\t\tvaluesMap[key].forEach(function(val){\n\t\t\t\t\t\tcount += val;\n\t\t\t\t\t});\n\t\t\t\t\tvar newValue = ( count ) / ( valuesMap[key].length );\n\t\t\t\t\tconsole.log( 'Interpolated field ' + field + 'with new value: ' + newValue );\n\t\t\t\t\tdata[field] = newValue;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// add the new data in\n\t\t\t\t\tif(valuesMap[key].length === WINDOW_SIZE){\n\t\t\t\t\t\tvaluesMap.splice(0, 1);\n\t\t\t\t\t}\n\t\t\t\t\tvaluesMap[key].push(data[field]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(data[field] !== null){\n\t\t\t\tvaluesMap[key] = [data[Field]];\n\t\t\t}\n\t\t}\n\t});\n\tpubsub.publish(publish_topic, data);\n}\n\npubsub.on('ready', function(){\n\tsetup();\n\tconsole.log('Beginning Interpolation');\n\tpubsub.subscribe(pubsub_topic, interpolate);\n});\n\n","count":1,"required_memory":1,"component_id":"5baa760a8b92e34c53340a57"},{"name":"BloomFilterCheck.js","source":"var things = require('things-js');\nvar bloom = require('bloomfilter').BloomFilter;\nvar fs = require('fs');\n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/ETL/RangeFilterCheck';\nvar publish_topic = 'thingsjs/IoTBench/ETL/BloomFilterCheck';\n\n\n/* bloom filter properties */\nvar DEFAULT_FALSEPOSITIVE = 0.1;\nvar DEFAULT_INSERTIONS = 20000000\nvar bloomFilter, testingRange, useMsgField;\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\nfunction getFilterSize(n, fpp){\n\treturn (-1) * Math.ceil( ( n * Math.log(fpp) ) / Math.pow(Math.log(2), 2) );\n}\n\nfunction getNumHashes(m, n){\n\treturn Math.ceil((m / n) * Math.log(2));\n}\n\nfunction createBloomFilter(){\n\tvar args = process.argv.slice(2);\n\tvar properties;\n\n\t// default to TAXI property set if no specific property file is given\n\tif(!args.length){\n\t\targs = ['./TAXI_properties.json'];\n\t}\n\ttry{\n\t\tproperties = JSON.parse(fs.readFileSync(args[0], 'utf-8'));\n\t}\n\tcatch(e){\n\t\tconsole.log('Couldn\\'t fetch properties: ' + e);\n\t\tprocess.exit();\n\t}\n\tuseMsgField = properties['BLOOMFILTER.USE_MSG_FIELD'] || 0;\n\ttestingRange = properties['BLOOMFILTER.EXPECTED_INSERTIONS'] || DEFAULT_INSERTIONS\n\tvar m = getFilterSize(testingRange, properties['BLOOMFILTER.FALSEPOSITIVE_RATIO'] || DEFAULT_FALSEPOSITIVE);\n\tvar k = getNumHashes(m, testingRange);\n\n\tvar modelPath = properties['BLOOMFILTER.MODEL_PATH'];\n\tif(!modelPath){\n\t\tconsole.log('Couldn\\'t find existing model');\n\t\tprocess.exit();\n\t}\n\ttry{\n\t\tvar model = fs.readFileSync(modelPath);\n\t\tbloomFilter = new bloom(JSON.parse(model), k);\n\t}\n\tcatch(c){\n\t\tconsole.log('A problem occured: ' + c);\n\t\tprocess.exit();\n\t}\n}\n\nfunction doBloomFilter(data){\n\tvar value;\n\t// if user specified they want to use a specific field value\n\tif(useMsgField > 0){\n\t\tvar keys = Object.keys(data);\n\t\tvalue = data[keys[useMsgField-1]];\n\t}\n\telse{\n\t\t// generate a random value between 0 - testingRange\n\t\tvalue = Math.floor(Math.random() * testingRange + 1);\n\t}\n\tvar res = bloomFilter.test(String(value));\n\tconsole.log('Bloom filter tested: ' + res);\n\tif(res){\n\t\tpubsub.publish(publish_topic, data);\n\t}\n}\n\npubsub.on('ready', function(){\n\tcreateBloomFilter();\n\tconsole.log('Beginning bloom filter');\n\tpubsub.subscribe(pubsub_topic, doBloomFilter);\n});\n\n","count":1,"required_memory":1,"component_id":"5baa76448b92e34c53340a58"}]}