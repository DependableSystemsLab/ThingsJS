{"name":"benchmarkTRAINGFS","components":{"SenMLParse.js":{"code_name":"SenMLParse.js","source":" /* \n * SenMLParse file adapted from RIoTBench (SenMLParse.java)\n */\n\n//var things = require('things-js');\nvar things = require('things-js')\n\n\n/* configurable variables */\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLSpout';\nvar publish_topic = 'thingsjs/IoTBench/SenMLParse';\n\nvar pubsub = new things.Pubsub(pubsub_url);\n// mkdir RIOT/ETL folder if not exist \n// save file inside \nfunction processMessage(data) {\n\tvar line = data.toString();\n\t\n\t// Remove everything before first { -- dunno why the data is made like that\n\tvar trimmedLine = line.substr(line.indexOf('{'));\n\t\n\t// JSON-parse object\n\tvar obj = JSON.parse(trimmedLine);\n\t//console.log(obj);\n\t\n\t// What follows is derived from the logic in SenMLParse\n\t// Ensuring compatibility as much as possible so that we can properly\n\t// implement / port the next \"steps\".\n\tvar baseTime = 'bt' in obj ? obj['bt'] : 0;\n\tvar baseUnit = 'bu' in obj ? obj['bu'] : \"\";\n\tvar baseName = 'bn' in obj ? obj['bn'] : \"\";\n\tvar jsonArr = obj['e'];\n\t\n\tvar v,n,u,t;\n\t\n\tvar mapkeyvalues = {};\n\t\n\t//console.log(jsonArr);\n\t\n\tfor (var j=0; j<jsonArr.length; j++) {\n\t\tvar jsonObject = jsonArr[j];\n\t\t//console.log(jsonObject);\n\n\t\tv = 'v' in jsonObject ? jsonObject['v'] : jsonObject['sv'];\n\t\tt = 'v' in jsonObject ? jsonObject['t'] : 0;\n\t\tt += baseTime;\n\n\t\t/* if name does not exist, consider base name */\n\t\tn = 'n' in jsonObject ? jsonObject['n'] : baseName;\n\t\tu = 'u' in jsonObject ? jsonObject['u'] : baseUnit;\n\n\t\tmapkeyvalues[n] = v;\n\t}\n\t\n\t\n\t// Publish the output\n// \tconsole.log(mapkeyvalues);\n    pubsub.publish(publish_topic, mapkeyvalues);\n}\n\n/* Connect pubsub */\npubsub.on('ready', function(){\n    \n\t// Subscribe to spout publications\n\tpubsub.subscribe(pubsub_topic, processMessage);\n});\n","count":1,"required_memory":1},"SenMLSpout.js":{"code_name":"SenMLSpout.js","source":"/* \n * Publishes SenML data over pub sub\n */\n\n//var things = require('things-js');\nvar things = require('things-js');\nvar readline = require('readline');\nvar mongoUrl = 'mongodb://localhost:27017/things-js-fs';\nvar GFS = require('things-js').addons.gfs(mongoUrl);\n\n\n/* configurable variables */\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLSpout';\nvar publish_interval = 1000;\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\n/* SenML Lines */\nvar lines = [];\nvar currentLine = 0;\n\n// function startSpout() {\n// \tvar lineReader = readline.createInterface({\n// \t\tinput: require('fs').createReadStream('TAXI_sample_data_senml.csv')\n// \t});\n\n// \tlineReader.on('line', function (line) {\n// \t\t//console.log('Line from file:', line);\n// \t\tlines.push(line);\n// \t});\n\n// \tlineReader.on('close', function() {\n// \t\t// File ended\n// \t\tconsole.log('Done reading file... Starting to publish');\n// \t\tsetInterval(publishLine, publish_interval);\n// \t});\t\n// }\nfunction startSpout() {\n\t var args = ['./TAXI_sample_data_senml.csv'];\n    GFS.readFile(args[0], function(err2, data) {\n        if (err2) {\n            console.log('\\x1b[44m%s\\x1b[0m', 'Couldn\\'t fetch properties: ' + err2);\n            process.exit();\n        }\n        var Readable = require('stream').Readable;\n\n        var taxiDataStream = new Readable();\n        taxiDataStream.push(data); // the string you want\n        taxiDataStream.push(null); // indicates end-of-file basically - the end of the stream\n        var lineReader = readline.createInterface({\n            input: taxiDataStream\n        });\n\n        lineReader.on('line', function(line) {\n            //console.log('Line from file:', line);\n            lines.push(line);\n        });\n\n        lineReader.on('close', function() {\n            // File ended\n            console.log('Done reading file... Starting to publish');\n            setInterval(publishLine, publish_interval);\n        });\n\n    });\n}\n\n/* Publish a SenML line */\nfunction publishLine() {\n    // For the moment, publish as a raw string rather than json-serializing\n    // since de-jsoning will be performed by the next 'bolt'\n    if (currentLine >= lines.length) {\n        /*\n        console.log(\"Done sending data.\");\n        return;\n        */\n        currentLine = 0;\n    }\n    console.log(\"Publishing line \" + currentLine);\n    pubsub.publish(pubsub_topic, lines[currentLine]);\n    currentLine++;\n}\n\npubsub.on('ready', function() {\n    console.log(\"Beginning spout\");\n    startSpout();\n});","count":1,"required_memory":1},"MultiLinearRegressionTrain.js":{"code_name":"MultiLinearRegressionTrain.js","source":"var fs = require('fs');\nvar MLR  = require('ml-regression-multivariate-linear');\nvar things = require('things-js');  \nvar mongoUrl = 'mongodb://localhost:27017/things-js-fs';\nvar GFS = require('things-js').addons.gfs(mongoUrl);\n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLParse';\nvar publish_topic = 'thingsjs/IoTBench/TRAIN/MultiLinearRegressionTrain';\n\nvar pubsub = new things.Pubsub(pubsub_url);\nvar USE_MSG_FIELD_LIST; \nvar SAMPLE_HEADER;\nvar MODEL_FILE_PATH;\nvar MODEL_UPDATE_FREQUENCY;\nvar TRAIN_INPUT;\nvar TRAIN_OUTPUT;\nvar TRAIN_INPUT_TYPE;\nvar WINDOW_COUNT = 10;\nvar traincount;\nvar datalist=[];\nvar processeddata;\n\nfunction setup(){\n  var args = process.argv.slice(2);\n  var properties;\n\n  // default to TAXI property set if no specific property file is given\n  if(!args.length){\n    args = ['./TAXI_properties.json'];\n  }\n  // try{\n    GFS.readFile(args[0], function(err2, data){\n        if (err2) {\n          console.log('\\x1b[44m%s\\x1b[0m', 'Couldn\\'t fetch properties: ' + err2);\n         process.exit();}\n      properties = JSON.parse(data);\n      USE_MSG_FIELD_LIST = properties['PREDICT.MULTIPLELINEAR_REGRESSION.USE_MSG_FIELD_LIST'];\n      USE_MSG_FIELD = properties[\"PREDICT.MULTIPLELINEAR_REGRESSION.USE_MSG_FIELD\"]||0;\n      SAMPLE_HEADER = properties[\"CLASSIFICATION.DECISION_TREE.SAMPLE_HEADER\"];\n      MODEL_FILE_PATH = properties[\"PREDICT.MULTIPLELINEAR_REGRESSION.MODEL_PATH\"];\n      MODEL_UPDATE_FREQUENCY = properties[\"PREDICT.MULTIPLELINEAR_REGRESSION.TRAIN.MODEL_UPDATE_FREQUENCY\"];\n      TRAIN_INPUT = properties[\"TRAIN.MULTIPLELINEAR_REGRESSION.TRAIN_INPUT\"];\n      TRAIN_OUTPUT = properties[\"TRAIN.MULTIPLELINEAR_REGRESSION.TRAIN_OUTPUT\"];\n      TRAIN_INPUT_TYPE = properties[\"TRAIN.MULTIPLELINEAR_REGRESSION.TRAIN_INPUT_TYPE\"];\n      console.log(\"USE_MSG_FIELD\" + USE_MSG_FIELD);\n      console.log(\"SAMPLE_HEADER\" + SAMPLE_HEADER);\n      console.log(\"MODEL_FILE_PATH\" + MODEL_FILE_PATH);\n      console.log(\"MODEL_UPDATE_FREQUENCY\" + MODEL_UPDATE_FREQUENCY);\n\n      if(!USE_MSG_FIELD_LIST){\n        console.log('No fields to TRAIN');\n        process.exit();\n      }\n\n    traincount = 0;\n    datalist = [];\n    console.log('Beginning training by decisiontree');\n    pubsub.subscribe(pubsub_topic, MultiLinearRegressionTrain);\n    });   \n  // }\n  // catch(e){\n  //   console.log('Couldn\\'t fetch properties: ' + e);\n  //   process.exit();\n  // }\n\n\n}\n\n\nfunction MultiLinearRegressionTrain(data){\n\n    var features = TRAIN_INPUT;\n    var target = TRAIN_OUTPUT;\n    var featureTypes = TRAIN_INPUT_TYPE;\n    var target_data = [];\n    datalist.push(data);\n    traincount ++;\n\n    if(traincount >= WINDOW_COUNT){\n      traincount = 0;\n    console.log(\"collect \" + WINDOW_COUNT + \" data to train by decisionTree\");\n    feature_data = processdata(datalist,features);\n    datalist.forEach(function(element){\n      var newArray = [];\n      newArray.push(Number(element[target]));\n      target_data.push(newArray);\n    });\n    console.log(\"TARGET_DATA\" + target_data);\n\n    var mlr = new MLR(feature_data, target_data);\n    console.log(mlr);\n    console.log('\\n\\n\\n');\n    var weights = mlr.weights;\n    console.log(weights);\n      //pubsub.publish(publish_topic,c45.toJSON()); no pubsub to make it stateless for prediction\n    GFS.writeFile(MODEL_FILE_PATH, JSON.stringify(weights), function(err){\n      if(err) \n        {\n          throw err;\n        }\n      datalist = [];\n    });\n  }\n}\n\n\n\nfunction processdata(datalist,features){\nvar resultdata =[];\n\ndatalist.forEach(function(element){\n  var newdatalist = [];\n  features.forEach(function(key){\n   newdatalist.push(Number(element[key]));\n  })\n  resultdata.push(newdatalist);\n});\n\n\nconsole.log(resultdata);\nreturn resultdata;\n}\n\n\n\n\npubsub.on('ready', function(){ \n  setup();\n\n});","count":1,"required_memory":1},"DecisionTreeTrain.js":{"code_name":"DecisionTreeTrain.js","source":"var fs = require('fs');\nvar csv = require('csv');\nvar C45 = require('c4.5');\nvar things = require('things-js'); \nvar mongoUrl = 'mongodb://localhost:27017/things-js-fs';\nvar GFS = require('things-js').addons.gfs(mongoUrl);\n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/TRAIN/DecisionTreeClassify';\nvar publish_topic = 'thingsjs/IoTBench/TRAIN/DecisionTreeTrain';\n\nvar pubsub = new things.Pubsub(pubsub_url);\nvar USE_MSG_FIELD_LIST; \nvar SAMPLE_HEADER;\nvar MODEL_FILE_PATH;\nvar MODEL_UPDATE_FREQUENCY;\nvar TRAIN_RESULT_HEADER;\nvar MODEL_TRAIN_INPUT;\nvar WINDOW_COUNT = 10;\nvar traincount;\nvar datalist=[];\nvar processeddata;\n\nfunction setup(){\n  var args = process.argv.slice(2);\n  var properties;\n\n  // default to TAXI property set if no specific property file is given\n  if(!args.length){\n    args = ['./TAXI_properties.json'];\n  }\n   GFS.readFile(args[0], function(err2, data){\n        if (err2) {\n          console.log('\\x1b[44m%s\\x1b[0m', 'Couldn\\'t fetch properties: ' + err2);\n          process.exit();\n        }\n        properties = JSON.parse(data);\n        USE_MSG_FIELD_LIST = properties['TRAIN.DECISION_TREE.USE_MSG_FIELD_LIST'];\n        USE_MSG_FIELD = properties['TRAIN.DECISION_TREE.USE_MSG_FIELD']||0;\n        MODEL_TRAIN_INPUT = properties[\"CLASSIFICATION.DECISION_TREE.SAMPLE_HEADER\"];\n        MODEL_FILE_PATH = properties['TRAIN.DECISION_TREE.MODEL_PATH'];\n        MODEL_UPDATE_FREQUENCY = properties[\"TRAIN.DECISION_TREE.TRAIN.MODEL_UPDATE_FREQUENCY\"];\n        TRAIN_RESULT_HEADER = properties['TRAIN.DECISION_TREE.TARGET'];\n        MODEL_TRAIN_INPUT = properties['TRAIN.DECISION_TREE.TRAIN_INPUT'];\n        MODEL_TRAIN_INPUT_TYPE = properties['TRAIN.DECISION_TREE.TRAIN_INPUT_TYPE'];\n\n        console.log(\"USE_MSG_FIELD\" + USE_MSG_FIELD);\n        console.log(\"MODEL_FILE_PATH\" + MODEL_FILE_PATH);\n        console.log(\"MODEL_UPDATE_FREQUENCY\" + MODEL_UPDATE_FREQUENCY);\n\n        if(!USE_MSG_FIELD_LIST){\n          console.log('No fields to TRAIN');\n          process.exit();\n        }\n\n        traincount = 0;\n        datalist = [];\n        console.log('Beginning training by decisiontree');\n        pubsub.subscribe(pubsub_topic, decisionTreeTrain);\n        });   \n\n}\n\n\nfunction decisionTreeTrain(saveddatalist){\n\n      var features = MODEL_TRAIN_INPUT;\n      var target = TRAIN_RESULT_HEADER;\n      var featureTypes = MODEL_TRAIN_INPUT_TYPE;\n\n      processeddata = processdata(saveddatalist,features,target);\n      var c45 = C45(); \n      c45.train({\n        data: processeddata,\n        target: target,\n        features: features,\n        featureTypes: featureTypes\n    }, function(error, model) {\n      if (error) {\n        console.error(error);\n        return false;\n      }  \n      console.log(\"tree model\"+ model.toJSON());\n      console.log(\"TRAIN DECISION TREE MODEL\",c45.toJSON());\n      //pubsub.publish(publish_topic,c45.toJSON()); no pubsub to make it stateless for prediction\n      GFS.writeFile(MODEL_FILE_PATH, c45.toJSON(),function(err){\n        if(err) throw err;\n      GFS.readFile(MODEL_FILE_PATH, function(err2, data){\n          if (err2) throw err2;\n          console.log(\"successfully wrote model\" + data.toString());\n      });\n    });\n\n    });\n\n} \n\n\nfunction processdata(saveddatalist,features,target){\nvar resultdata =[];\n\nsaveddatalist.forEach(function(element){\n  var newdatalist = [];\n  features.forEach(function(key){\n   newdatalist.push(element[key]);\n  })\n  newdatalist.push(element[target]);\n  resultdata.push(newdatalist);\n});\n\nresultdata.forEach(function(array){\n  console.log(array);\n});\nreturn resultdata;\n}\n\n\n\n\npubsub.on('ready', function(){\n  setup();\n});","count":1,"required_memory":1},"DecisionTreeClassify.js":{"code_name":"DecisionTreeClassify.js","source":"var things = require('things-js');  \nvar csv = require('csv');\nvar C45 = require('c4.5');\nvar things = require('things-js');\nvar math = require('mathjs');\nvar fs = require('fs');\nvar mongoUrl = 'mongodb://localhost:27017/things-js-fs';\nvar GFS = require('things-js').addons.gfs(mongoUrl);\n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLParse';\nvar publish_topic = 'thingsjs/IoTBench/TRAIN/DecisionTreeClassify';\n\nvar pubsub = new things.Pubsub(pubsub_url);\nvar USE_MSG_FIELD_LIST; \nvar SAMPLE_HEADER;\nvar MODEL_FILE_PATH;\nvar MODEL_UPDATE_FREQUENCY;\nvar WINDOW_COUNT = 10;\nvar TRAIN_RESULT_HEADER;\nvar CLASS_HEADER;\nvar traincount;\nvar datalist;\nvar processeddata;\nvar classification;\n\nfunction setup() {\n    var args = process.argv.slice(2);\n    var properties;\n\n    // default to TAXI property set if no specific property file is given\n    if (!args.length) {\n        args = ['./TAXI_properties.json'];\n    }\n\n    GFS.readFile(args[0], function(err2, data){\n        if (err2) {\n          console.log('\\x1b[44m%s\\x1b[0m', 'Couldn\\'t fetch properties: ' + err2);\n          process.exit();\n        }\n            properties = JSON.parse(data);\n            USE_MSG_FIELD_LIST = properties['CLASSIFICATION.DECISION_TREE.USE_MSG_FIELD_LIST'];\n            USE_MSG_FIELD = properties['CLASSIFICATION.DECISION_TREE.USE_MSG_FIELD'] || 0;\n            //SAMPLE_HEADER = properties[\"CLASSIFICATION.DECISION_TREE.SAMPLE_HEADER\"];\n            MODEL_FILE_PATH = properties['CLASSIFICATION.DECISION_TREE.MODEL_PATH'];\n            MODEL_UPDATE_FREQUENCY = properties[\"CLASSIFICATION.DECISION_TREE.TRAIN.MODEL_UPDATE_FREQUENCY\"];\n            TRAIN_RESULT_HEADER = properties[\"CLASSIFICATION.DECISION_TREE.TRAIN.RESULT_ATTRIBUTE\"];\n            CLASS_HEADER = properties[\"CLASSIFICATION.DECISION_TREE.TRAIN.CLASS_HEADER\"];\n            console.log(\"USE_MSG_FIELD\" + USE_MSG_FIELD);\n            console.log(\"MODEL_FILE_PATH\" + MODEL_FILE_PATH);\n            console.log(\"MODEL_UPDATE_FREQUENCY\" + MODEL_UPDATE_FREQUENCY);\n\n            if (!USE_MSG_FIELD_LIST) {\n                console.log('No fields to TRAIN');\n                process.exit();\n            }\n\n          traincount = 0;\n          datalist = [];\n          console.log('Beginning classify the decisiontree');\n          pubsub.subscribe(pubsub_topic, DecisionTreeClassify);\n        });     \n    // } catch (e) {\n    //     console.log('Couldn\\'t fetch properties: ' + e);\n    //     process.exit();\n    // }\n\n\n}\n\nfunction DecisionTreeClassify(data){\n\ntraincount ++;\nvar target =\"total_amount\";\ndatalist.push(data);\n\nif(traincount>= WINDOW_COUNT){\n    traincount = 0;\n    var quantileArray = [];\n    datalist.forEach(function(element){\n        quantileArray.push(element[TRAIN_RESULT_HEADER]);\n    });\n    var bar1 = math.quantileSeq(quantileArray, 0.25);\n    var bar2 = math.quantileSeq(quantileArray, 0.50);\n    var bar3 = math.quantileSeq(quantileArray, 0.75);\n    var bar4 = math.quantileSeq(quantileArray, 1);\n\n    datalist.forEach(function(element){\n        element[CLASS_HEADER] = getQuantile(element[TRAIN_RESULT_HEADER], bar1, bar2, bar3, bar4);\n    });\n\n    pubsub.publish(publish_topic,datalist);\n    console.log(\"CLASSIFIED DATA\" + datalist);\n    datalist = [];\n\t}\n}\n\n\nfunction getQuantile(data, bar1, bar2, bar3, bar4){\n  if(data< bar1){\n    return \"BAD\";\n  }\n  if(data >= bar1 && data<bar2){\n    return \"GOOD\";\n  }\n  if(data >= bar2 && data < bar3){\n    return \"VERY GOOD\";\n  }\n  if(data >= bar3 & data <= bar4){\n    return \"EXCELLENT\";\n  }\n}\n\n\n\n\npubsub.on('ready', function(){\n  setup();\n});","count":1,"required_memory":1}}}