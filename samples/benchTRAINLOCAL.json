{"name":"testTRAIN","components":[{"name":"SenMLParse.js","source":"/* \n * SenMLParse file adapted from RIoTBench (SenMLParse.java)\n */\n\n//var things = require('things-js');\nvar things = require('things-js')\n\n/* configurable variables */\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLSpout';\nvar publish_topic = 'thingsjs/IoTBench/SenMLParse';\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\nfunction processMessage(data) {\n\tvar line = data.toString();\n\t\n\t// Remove everything before first { -- dunno why the data is made like that\n\tvar trimmedLine = line.substr(line.indexOf('{'));\n\t\n\t// JSON-parse object\n\tvar obj = JSON.parse(trimmedLine);\n\t//console.log(obj);\n\t\n\t// What follows is derived from the logic in SenMLParse\n\t// Ensuring compatibility as much as possible so that we can properly\n\t// implement / port the next \"steps\".\n\tvar baseTime = 'bt' in obj ? obj['bt'] : 0;\n\tvar baseUnit = 'bu' in obj ? obj['bu'] : \"\";\n\tvar baseName = 'bn' in obj ? obj['bn'] : \"\";\n\tvar jsonArr = obj['e'];\n\t\n\tvar v,n,u,t;\n\t\n\tvar mapkeyvalues = {};\n\t\n\t//console.log(jsonArr);\n\t\n\tfor (var j=0; j<jsonArr.length; j++) {\n\t\tvar jsonObject = jsonArr[j];\n\t\t//console.log(jsonObject);\n\n\t\tv = 'v' in jsonObject ? jsonObject['v'] : jsonObject['sv'];\n\t\tt = 'v' in jsonObject ? jsonObject['t'] : 0;\n\t\tt += baseTime;\n\n\t\t/* if name does not exist, consider base name */\n\t\tn = 'n' in jsonObject ? jsonObject['n'] : baseName;\n\t\tu = 'u' in jsonObject ? jsonObject['u'] : baseUnit;\n\n\t\tmapkeyvalues[n] = v;\n\t}\n\t\n\t\n\t// Publish the output\n\tconsole.log(mapkeyvalues);\n    pubsub.publish(publish_topic, mapkeyvalues);\n}\n\n/* Connect pubsub */\npubsub.on('ready', function(){\n    \n\t// Subscribe to spout publications\n\tpubsub.subscribe(pubsub_topic, processMessage);\n});\n","count":1,"required_memory":1,"component_id":"5ba0511c8797ac7bc20a731a"},{"name":"SenMLSpout.js","source":"/* \n * Publishes SenML data over pub sub\n */\n\n//var things = require('things-js');\nvar things = require('things-js');\nvar readline = require('readline');\n\n/* configurable variables */\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLSpout';\nvar publish_interval = 1000;\n\nvar pubsub = new things.Pubsub(pubsub_url);\n\n/* SenML Lines */\nvar lines = [];\nvar currentLine = 0;\n\nfunction startSpout() {\n\tvar lineReader = readline.createInterface({\n\t\tinput: require('fs').createReadStream('TAXI_sample_data_senml.csv')\n\t});\n\n\tlineReader.on('line', function (line) {\n\t\t//console.log('Line from file:', line);\n\t\tlines.push(line);\n\t});\n\n\tlineReader.on('close', function() {\n\t\t// File ended\n\t\tconsole.log('Done reading file... Starting to publish');\n\t\tsetInterval(publishLine, publish_interval);\n\t});\t\n}\n\n/* Publish a SenML line */\nfunction publishLine() {\n\t// For the moment, publish as a raw string rather than json-serializing\n\t// since de-jsoning will be performed by the next 'bolt'\n\tif (currentLine >= lines.length) {\n\t\t/*\n\t\tconsole.log(\"Done sending data.\");\n\t\treturn;\n\t\t*/\n\t   currentLine = 0;\n\t}\n\tconsole.log(\"Publishing line \" + currentLine);\n\tpubsub.publish(pubsub_topic, lines[currentLine]);\n\tcurrentLine++;\n}\n\npubsub.on('ready', function(){\n    console.log(\"Beginning spout\");\n    startSpout();\n});\n\n","count":1,"required_memory":1,"component_id":"5ba0513d8797ac7bc20a731b"},{"name":"MultiLinearRegressionTrain.js","source":"var fs = require('fs');\nvar MLR  = require('ml-regression-multivariate-linear');\nvar things = require('things-js');  \n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLParse';\nvar publish_topic = 'thingsjs/IoTBench/TRAIN/MultiLinearRegressionTrain';\n\nvar pubsub = new things.Pubsub(pubsub_url);\nvar USE_MSG_FIELD_LIST; \nvar SAMPLE_HEADER;\nvar MODEL_FILE_PATH;\nvar MODEL_UPDATE_FREQUENCY;\nvar TRAIN_INPUT;\nvar TRAIN_OUTPUT;\nvar WINDOW_COUNT = 10;\nvar traincount;\nvar datalist;\nvar processeddata;\n\nfunction setup(){\n  var args = process.argv.slice(2);\n  var properties;\n\n  // default to TAXI property set if no specific property file is given\n  if(!args.length){\n    args = ['./TAXI_properties.json'];\n  }\n  try{\n    properties = JSON.parse(fs.readFileSync(args[0], 'utf-8'));\n\n    USE_MSG_FIELD_LIST = properties['PREDICT.MULTIPLELINEAR_REGRESSION.USE_MSG_FIELD_LIST'];\n    USE_MSG_FIELD = properties[\"PREDICT.MULTIPLELINEAR_REGRESSION.USE_MSG_FIELD\"]||0;\n    SAMPLE_HEADER = properties[\"CLASSIFICATION.DECISION_TREE.SAMPLE_HEADER\"];\n    MODEL_FILE_PATH = properties[\"PREDICT.MULTIPLELINEAR_REGRESSION.MODEL_PATH\"];\n    MODEL_UPDATE_FREQUENCY = properties[\"PREDICT.MULTIPLELINEAR_REGRESSION.TRAIN.MODEL_UPDATE_FREQUENCY\"];\n    TRAIN_INPUT = properties[\"TRAIN.MULTIPLELINEAR_REGRESSION.TRAIN_INPUT\"];\n    TRAIN_OUTPUT = properties[\"TRAIN.MULTIPLELINEAR_REGRESSION.TRAIN_OUTPUT\"];\n    TRAIN_INPUT_TYPE = properties[\"TRAIN.MULTIPLELINEAR_REGRESSION.TRAIN_INPUT_TYPE\"];\n    console.log(\"USE_MSG_FIELD\" + USE_MSG_FIELD);\n    console.log(\"SAMPLE_HEADER\" + SAMPLE_HEADER);\n    console.log(\"MODEL_FILE_PATH\" + MODEL_FILE_PATH);\n    console.log(\"MODEL_UPDATE_FREQUENCY\" + MODEL_UPDATE_FREQUENCY);\n\n    if(!USE_MSG_FIELD_LIST){\n      console.log('No fields to TRAIN');\n      process.exit();\n    }\n  }\n  catch(e){\n    console.log('Couldn\\'t fetch properties: ' + e);\n    process.exit();\n  }\n  traincount = 0;\n  datalist = [];\n\n}\n\n\nfunction MultiLinearRegressionTrain(data){\n\n    // fs.writeFileSync(\"./parseddata2.json\",data);\n    var features = TRAIN_INPUT;\n    var target = TRAIN_OUTPUT;\n    var featureTypes = TRAIN_INPUT_TYPE;\n    var target_data = [];\n    datalist.push(data);\n    console.log(\"length of data\" + datalist.length );\n    traincount ++;\n\n    if(traincount >= WINDOW_COUNT){\n      traincount = 0;\n    console.log(\"collect 100 data to train by decisionTree\");\n    feature_data = processdata(datalist,features);\n    datalist.forEach(function(element){\n      var newArray = [];\n      newArray.push(Number(element[target]));\n      target_data.push(newArray);\n    });\n    console.log(\"TARGET_DATA\" + target_data);\n\n    var mlr = new MLR(feature_data, target_data);\n    console.log(mlr);\n    console.log('\\n\\n\\n');\n    var weights = mlr.weights;\n    console.log(weights);\n      //pubsub.publish(publish_topic,c45.toJSON()); no pubsub to make it stateless for prediction\n    fs.writeFileSync(MODEL_FILE_PATH, JSON.stringify(weights));\n    datalist = [];\n  }\n}\n\n\n\nfunction processdata(datalist,features){\nvar resultdata =[];\n\ndatalist.forEach(function(element){\n  var newdatalist = [];\n  features.forEach(function(key){\n   newdatalist.push(Number(element[key]));\n  })\n  resultdata.push(newdatalist);\n});\n\n\nconsole.log(resultdata);\nreturn resultdata;\n}\n\n\n\n\npubsub.on('ready', function(){\n  setup();\n  console.log('Beginning training by decisiontree');\n  pubsub.subscribe(pubsub_topic, MultiLinearRegressionTrain);\n});","count":1,"required_memory":1,"component_id":"5baa7ba97bc32f56db7a740c"},{"name":"DecisionTreeTrain.js","source":"var fs = require('fs');\nvar csv = require('csv');\nvar C45 = require('c4.5');\nvar things = require('things-js'); \n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/TRAIN/DecisionTreeClassify';\nvar publish_topic = 'thingsjs/IoTBench/TRAIN/DecisionTreeTrain';\n\nvar pubsub = new things.Pubsub(pubsub_url);\nvar USE_MSG_FIELD_LIST; \nvar SAMPLE_HEADER;\nvar MODEL_FILE_PATH;\nvar MODEL_UPDATE_FREQUENCY;\nvar TRAIN_RESULT_HEADER;\nvar MODEL_TRAIN_INPUT;\nvar WINDOW_COUNT = 10;\nvar traincount;\nvar datalist;\nvar processeddata;\n\nfunction setup(){\n  var args = process.argv.slice(2);\n  var properties;\n\n  // default to TAXI property set if no specific property file is given\n  if(!args.length){\n    args = ['./TAXI_properties.json'];\n  }\n  try{\n    properties = JSON.parse(fs.readFileSync(args[0], 'utf-8'));\n\n    USE_MSG_FIELD_LIST = properties['TRAIN.DECISION_TREE.USE_MSG_FIELD_LIST'];\n    USE_MSG_FIELD = properties['TRAIN.DECISION_TREE.USE_MSG_FIELD']||0;\n    MODEL_TRAIN_INPUT = properties[\"CLASSIFICATION.DECISION_TREE.SAMPLE_HEADER\"];\n    MODEL_FILE_PATH = properties['TRAIN.DECISION_TREE.MODEL_PATH'];\n    MODEL_UPDATE_FREQUENCY = properties[\"TRAIN.DECISION_TREE.TRAIN.MODEL_UPDATE_FREQUENCY\"];\n    TRAIN_RESULT_HEADER = properties['TRAIN.DECISION_TREE.TARGET'];\n    MODEL_TRAIN_INPUT = properties['TRAIN.DECISION_TREE.TRAIN_INPUT'];\n    MODEL_TRAIN_INPUT_TYPE = properties['TRAIN.DECISION_TREE.TRAIN_INPUT_TYPE'];\n\n    console.log(\"USE_MSG_FIELD\" + USE_MSG_FIELD);\n    console.log(\"MODEL_FILE_PATH\" + MODEL_FILE_PATH);\n    console.log(\"MODEL_UPDATE_FREQUENCY\" + MODEL_UPDATE_FREQUENCY);\n\n    if(!USE_MSG_FIELD_LIST){\n      console.log('No fields to TRAIN');\n      process.exit();\n    }\n  }\n  catch(e){\n    console.log('Couldn\\'t fetch properties: ' + e);\n    process.exit();\n  }\n  traincount = 0;\n  datalist = [];\n\n}\n\n\nfunction decisionTreeTrain(datalist){\n\n      var features = MODEL_TRAIN_INPUT;\n      var target = TRAIN_RESULT_HEADER;\n      var featureTypes = MODEL_TRAIN_INPUT_TYPE;\n\n      processeddata = processdata(datalist,features,target);\n      var c45 = C45(); \n      c45.train({\n        data: processeddata,\n        target: target,\n        features: features,\n        featureTypes: featureTypes\n    }, function(error, model) {\n      if (error) {\n        console.error(error);\n        return false;\n      }  \n      console.log(\"tree model\"+ model.toJSON());\n      console.log(\"TRAIN DECISION TREE MODEL\",c45.toJSON());\n      //pubsub.publish(publish_topic,c45.toJSON()); no pubsub to make it stateless for prediction\n      // USE GFS API SAVE TO RIOT/TRAIN\n      fs.writeFileSync(MODEL_FILE_PATH, c45.toJSON());\n\n    });\n\n} \n\n\nfunction processdata(datalist,features,target){\nvar resultdata =[];\n\ndatalist.forEach(function(element){\n  var newdatalist = [];\n  features.forEach(function(key){\n   newdatalist.push(element[key]);\n  })\n  newdatalist.push(element[target]);\n  resultdata.push(newdatalist);\n});\n\nresultdata.forEach(function(array){\n  console.log(\"lalala\"+array);\n});\nreturn resultdata;\n}\n\n\n\n\npubsub.on('ready', function(){\n  setup();\n  console.log('Beginning training by decisiontree');\n  pubsub.subscribe(pubsub_topic, decisionTreeTrain);\n});","count":1,"required_memory":1,"component_id":"5baa7b7c7bc32f56db7a740b"},{"name":"DecisionTreeClassify.js","source":"var things = require('things-js');  \n var fs = require('fs');\n var csv = require('csv');\nvar C45 = require('c4.5');\nvar things = require('things-js');\nvar math = require('mathjs');\n\nvar pubsub_url = 'mqtt://localhost';\nvar pubsub_topic = 'thingsjs/IoTBench/SenMLParse';\nvar publish_topic = 'thingsjs/IoTBench/TRAIN/DecisionTreeClassify';\n\nvar pubsub = new things.Pubsub(pubsub_url);\nvar USE_MSG_FIELD_LIST; \nvar SAMPLE_HEADER;\nvar MODEL_FILE_PATH;\nvar MODEL_UPDATE_FREQUENCY;\nvar WINDOW_COUNT = 30;\nvar TRAIN_RESULT_HEADER;\nvar CLASS_HEADER;\nvar traincount;\nvar datalist;\nvar processeddata;\nvar classification;\n\nfunction setup() {\n    var args = process.argv.slice(2);\n    var properties;\n\n    // default to TAXI property set if no specific property file is given\n    if (!args.length) {\n        args = ['./TAXI_properties.json'];\n    }\n    try {\n        properties = JSON.parse(fs.readFileSync(args[0], 'utf-8'));\n\n        USE_MSG_FIELD_LIST = properties['CLASSIFICATION.DECISION_TREE.USE_MSG_FIELD_LIST'];\n        USE_MSG_FIELD = properties['CLASSIFICATION.DECISION_TREE.USE_MSG_FIELD'] || 0;\n        //SAMPLE_HEADER = properties[\"CLASSIFICATION.DECISION_TREE.SAMPLE_HEADER\"];\n        MODEL_FILE_PATH = properties['CLASSIFICATION.DECISION_TREE.MODEL_PATH'];\n        MODEL_UPDATE_FREQUENCY = properties[\"CLASSIFICATION.DECISION_TREE.TRAIN.MODEL_UPDATE_FREQUENCY\"];\n        TRAIN_RESULT_HEADER = properties[\"CLASSIFICATION.DECISION_TREE.TRAIN.RESULT_ATTRIBUTE\"];\n        CLASS_HEADER = properties[\"CLASSIFICATION.DECISION_TREE.TRAIN.CLASS_HEADER\"];\n        console.log(\"USE_MSG_FIELD\" + USE_MSG_FIELD);\n        //console.log(\"SAMPLE_HEADER\" + SAMPLE_HEADER);\n        console.log(\"MODEL_FILE_PATH\" + MODEL_FILE_PATH);\n        console.log(\"MODEL_UPDATE_FREQUENCY\" + MODEL_UPDATE_FREQUENCY);\n\n        if (!USE_MSG_FIELD_LIST) {\n            console.log('No fields to TRAIN');\n            process.exit();\n        }\n    } catch (e) {\n        console.log('Couldn\\'t fetch properties: ' + e);\n        process.exit();\n    }\n    traincount = 0;\n    datalist = [];\n\n}\n\nfunction DecisionTreeClassify(data){\n\ntraincount ++;\nvar target =\"total_amount\";\ndatalist.push(data);\n\nif(traincount>= WINDOW_COUNT){\n    traincount = 0;\n    var quantileArray = [];\n    datalist.forEach(function(element){\n        quantileArray.push(element[TRAIN_RESULT_HEADER]);\n    });\n    var bar1 = math.quantileSeq(quantileArray, 0.25);\n    var bar2 = math.quantileSeq(quantileArray, 0.50);\n    var bar3 = math.quantileSeq(quantileArray, 0.75);\n    var bar4 = math.quantileSeq(quantileArray, 1);\n\n    datalist.forEach(function(element){\n        element[CLASS_HEADER] = getQuantile(element[TRAIN_RESULT_HEADER], bar1, bar2, bar3, bar4);\n    });\n\n    pubsub.publish(publish_topic,datalist);\n    console.log(\"CLASSIFIED DATA\" + datalist);\n    datalist = [];\n\t}\n}\n\n\nfunction getQuantile(data, bar1, bar2, bar3, bar4){\n  if(data< bar1){\n    return \"BAD\";\n  }\n  if(data >= bar1 && data<bar2){\n    return \"GOOD\";\n  }\n  if(data >= bar2 && data < bar3){\n    return \"VERY GOOD\";\n  }\n  if(data >= bar3 & data <= bar4){\n    return \"EXCELLENT\";\n  }\n}\n\n\n\n\npubsub.on('ready', function(){\n  setup();\n  console.log('Beginning classify the decisiontree');\n  pubsub.subscribe(pubsub_topic, DecisionTreeClassify);\n});","count":1,"required_memory":1,"component_id":"5baa7b4f7bc32f56db7a740a"}]}